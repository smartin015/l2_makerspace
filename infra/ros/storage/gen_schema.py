# Generate typescript from particular flavors of ros message
import l2_msgs.msg as l2_msgs
import re

SCHEMA_FMT = """
-- THIS SCHEMA IS AUTOGENERATED
-- See gen_schema.py in l2_storage ros node
BEGIN;
{tables}

COMMIT;
"""

TABLE_FMT = """
CREATE TABLE IF NOT EXISTS {name} (
{cols}
);"""

COL_FMT = "  {name} {typ} {suffix}"

TYPE_SEP = ":"
TYPE_REL = ">"

def topological_sort(source):
    """perform topo sort on elements.
    https://stackoverflow.com/questions/11557241/python-sorting-a-dependency-list

    :arg source: list of ``(name, [list of dependancies])`` pairs
    :returns: list of names, with dependancies listed first
    """
    pending = [(name, set(deps)) for name, deps in source] # copy deps so we can modify set in-place       
    emitted = []
    while pending:
        next_pending = []
        next_emitted = []
        for entry in pending:
            name, deps = entry
            deps.difference_update(emitted) # remove deps we emitted last pass
            if deps: # still has deps? recheck during next pass
                next_pending.append(entry) 
            else: # no more deps? time to emit
                yield name 
                emitted.append(name) # <-- not required, but helps preserve original ordering
                next_emitted.append(name) # remember what we emitted for difference_update() in next pass
        if not next_emitted: # all entries have unmet deps, one of two things is wrong...
            raise ValueError("cyclic or missing dependancy detected: %r" % (next_pending,))
        pending = next_pending
        emitted = next_emitted

def to_pg_type(msg_type):
    return {
        "boolean": "BOOLEAN",
        "uint8": "CHAR(1)",
        "int32": "INTEGER",
        "int64": "BIGINT",
        "string": "TEXT",
        "sequence<octet>": "BYTEA",
        "builtin_interfaces/Time": "TIME",
    }.get(msg_type.strip(), "UNKNOWN")

def l2_type(pgtype):
    # Turns e.g. sequence<l2_msgs/L2Role> -> L2Role
    m = re.search(r"l2\_\w+\/(\w+)", pgtype)
    return m if m is None else m.group(1)

def toposorted_table_msgs(tblmap):
    graph = []
    # Only do toposort for keys that exist.
    # This allows us to construct tables
    # when the schema is incomplete
    keys = set(tblmap.keys())
    for name, msg in tblmap.items():
        graph.append((name, [v for v in msg[1].values() if v in keys]))
    print("Toposort: %s" % graph)
    return topological_sort(graph)

def annotate_msg(msg, tables):
    name = msg().__class__.__name__
    pgcols = [] if msg.PG_COLS == "all" else [c.strip() for c in msg.PG_COLS.split(' ')]
    exclude = [a[1:] for a in pgcols if a.startswith('-')]
    ft = {k:v for k,v in msg.get_fields_and_field_types().items() if k not in exclude}
    over = dict([a.split(TYPE_SEP, 1) for a in pgcols if TYPE_SEP in a])

    # Note: relations determined by pre-overridden columns 
    # since overridden columns are typically relational (e.g. project -> project_id)
    relations = dict([(k, l2_type(v)) for k,v in ft.items() if
            'l2' in v and l2_type(v) in tables])
    relations = {**relations,  **dict([i.split(TYPE_REL, 1) for i in pgcols if TYPE_REL in
        i])}

    merged = {**ft, **over}
    print("%s: orig %s, excluding %s, merging %s -> %s, relation %s" % (name, str(ft),
        str(exclude), str(over), str(merged), str(relations)))
    return [merged, relations]

def to_table(name, tcols, relations):
    cols = []
    for cn,ct in tcols.items():
        suffix = "REFERENCES %s(id)" % (relations[cn]) if cn in relations.keys() else ""
        ct = "SERIAL PRIMARY KEY" if cn == "id" else to_pg_type(ct)
        cols.append(COL_FMT.format(name=cn, typ=ct, suffix=suffix).rstrip())
    if tcols.get("id") is not None:
        cols = cols + ["UNIQUE (id)"]
    return TABLE_FMT.format(name=name,
                            cols=",\n".join(cols))

def get_table_msgs(include=None):
    if include is not None:
        include = [i.lower() for i in include]
    table_msgs = {}
    for msg in dir(l2_msgs):
        if msg.startswith("_"):
            continue
        msg = getattr(l2_msgs, msg)
        if not hasattr(msg, 'PG_COLS'):
            continue
        name = msg().__class__.__name__
        if include is not None and name.lower() not in include:
            continue
        table_msgs[name] = msg
    return table_msgs

def gen_schema(include=None):
    print("Gen Schema:", include)
    mmap = get_table_msgs(include)
    print("Messages:", mmap)
    annotated = dict([(k, annotate_msg(v, mmap.keys())) for k,v in mmap.items()])
    print("Annotated:", annotated)
    msgs = [[k, annotated[k][0], annotated[k][1]] for k in toposorted_table_msgs(annotated)]
    print(msgs)
    return SCHEMA_FMT.format(tables="\n\n".join([to_table(m[0], m[1], m[2]) for m in msgs]))

if __name__ == "__main__":
    import sys
    include = sys.argv[1:] if len(sys.argv) > 1 else None
    print(gen_schema(include))

