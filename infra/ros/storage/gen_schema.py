# Generate typescript from particular flavors of ros message
import l2_msgs.msg as l2_msgs
import re

SCHEMA_FMT = """
-- THIS SCHEMA IS AUTOGENERATED
-- See gen_schema.py in l2_storage ros node
BEGIN;
{tables}

COMMIT;
"""

TABLE_FMT = """
CREATE TABLE IF NOT EXISTS {name} (
{cols}
);"""

COL_FMT = "  {name} {typ} {suffix}"

TYPE_SEP = ":"
TYPE_REL = ">"

def topological_sort(source):
    """perform topo sort on elements.
    https://stackoverflow.com/questions/11557241/python-sorting-a-dependency-list

    :arg source: list of ``(name, [list of dependancies])`` pairs
    :returns: list of names, with dependancies listed first
    """
    pending = [(name, set(deps)) for name, deps in source] # copy deps so we can modify set in-place       
    emitted = []
    while pending:
        next_pending = []
        next_emitted = []
        for entry in pending:
            name, deps = entry
            deps.difference_update(emitted) # remove deps we emitted last pass
            if deps: # still has deps? recheck during next pass
                next_pending.append(entry) 
            else: # no more deps? time to emit
                yield name 
                emitted.append(name) # <-- not required, but helps preserve original ordering
                next_emitted.append(name) # remember what we emitted for difference_update() in next pass
        if not next_emitted: # all entries have unmet deps, one of two things is wrong...
            raise ValueError("cyclic or missing dependancy detected: %r" % (next_pending,))
        pending = next_pending
        emitted = next_emitted

def to_pg_type(msg_type):
    return {
        "boolean": "BOOLEAN",
        "uint8": "CHAR(1)",
        "int32": "INTEGER",
        "int64": "BIGINT",
        "string": "TEXT",
        "sequence<octet>": "BYTEA",
    }.get(msg_type.strip(), "UNKNOWN")

def l2_type(pgtype):
    # Turns e.g. sequence<l2_msgs/L2Role> -> L2Role
    m = re.search(r"l2\_\w+\/(\w+)", pgtype)
    return m if m is None else m.group(1)

def toposorted_table_msgs(tables):
    graph = []
    tblmap = dict([(m().__class__.__name__, m) for m in get_table_msgs()])
    for name, msg in tblmap.items():
        if name not in tables:
            continue
        deps = [l2_type(v) for k,v in msg.get_fields_and_field_types().items()]
        graph.append((name, [d for d in deps if d is not None]))
    print("Toposort: %s" % graph)
    return [tblmap[t] for t in topological_sort(graph)]

def annotate_msg(msg, tables):
    name = msg().__class__.__name__
    pgcols = [] if msg.PG_COLS == "all" else [c.strip() for c in msg.PG_COLS.split(' ')]
    exclude = [a[1:] for a in pgcols if a.startswith('-')]
    ft = {k:v for k,v in msg.get_fields_and_field_types().items() if k not in exclude}
    over = dict([a.split(TYPE_SEP, 1) for a in pgcols if TYPE_SEP in a])

    relations = dict([(k, l2_type(v)) for k,v in ft.items() if
            'l2' in v and l2_type(v) in tables])
    relations = {**relations,  **dict([i.split(TYPE_REL, 1) for i in pgcols if TYPE_REL in
        i])}

    merged = {**ft, **over}
    print("%s: orig %s, excluding %s, merging %s -> %s, relation %s" % (name, str(ft),
        str(exclude), str(over), str(merged), str(relations)))
    cols = []

def to_table(msgs, relations):
    for n,t in msgs.items():
        suffix = "REFERENCES %s(id)" % (relations[n]) if n in relations.keys() else ""
        cols.append(COL_FMT.format(name=n, typ=to_pg_type(t),
            suffix=suffix).rstrip())
    return TABLE_FMT.format(name=name,
                            cols=",\n".join(cols))

def get_table_msgs(include=None):
    table_msgs = {}
    for msg in dir(l2_msgs):
        if msg.startswith("_"):
            continue
        msg = getattr(l2_msgs, msg)
        if not hasattr(msg, 'PG_COLS'):
            continue
        name = m().__class__.__name__
        if include is not None and name not in include:
            continue
        table_msgs[name] = msg
    return table_msgs

def gen_schema(include=None):
    mmap = get_table_msgs(include)
    annotated = dict([(k, annotate_msg(v)) for k,v in mmap.items()])
    msgs = [annotated[k] for k in toposorted_table_names(annotated)]
    return SCHEMA_FMT.format(tables="\n\n".join([to_table(m) for m in msgs]))

if __name__ == "__main__":
    import sys
    include = sys.argv[1:] if len(sys.argv) > 1 else None
    print(gen_schema(include))

